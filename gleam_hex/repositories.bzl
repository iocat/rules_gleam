# Accept gleam.toml, generate manifest.toml
load("//internal:common.bzl", "env_execute", "executable_extension", "watch")

TEMP_DIR = ".__hexpkg__"

def copy(ctx, file, target, *, watch = "no"):
    f = ctx.path(file)
    if f.exists:
        ctx.file(target, ctx.read(file, watch = watch))
    else:
        ctx.file(target, "# No gleam.toml, probably not a gleam project.")


def _gleam_compiler_path(repository_ctx):
    platform_mapping = {
        ("mac os x", "aarch64"): "gleam_compiler_aarch64_apple_darwin",
        ("mac os x", "x86_64"): "gleam_compiler_x86_64_apple_darwin",
        ("windows", "aarch64"): "gleam_compiler_aarch64_pc_windows_msvc",
        ("windows", "x86_64"): "gleam_compiler_x86_64_pc_windows_msvc",
        ("linux", "aarch64"): "gleam_compiler_aarch64_unknown_linux_musl",
        ("linux", "x86_64"): "gleam_compiler_x86_64_unknown_linux_musl",
    }

    os_name = repository_ctx.os.name
    arch_name = repository_ctx.os.arch
    key = (os_name, arch_name)
    if key not in platform_mapping:
        fail("Unsupported host platform: {}/{}".format(os_name, arch_name))
    
    repo = platform_mapping[key]
    ext = ""
    if "windows" in repo:
        ext = ".exe"

    tool_label_string = "@%s//:gleam%s" % (repo, ext)
    tool_label = Label(tool_label_string)
    compiler_path = repository_ctx.path(tool_label)
    return compiler_path

def _gleam_hex_repository(ctx):
    tar_package_url = _hex_tar_url(ctx.attr.module_name, ctx.attr.version)
    ctx.report_progress("Downloading Repo")
    ctx.download_and_extract(
        url = tar_package_url,
        sha256 = ctx.attr.checksum,
        type = "tar",
        output = TEMP_DIR,
    )
    ctx.file("BUILD.bazel", """# This file is generated by the @rules_gleam//:gleam_hex/repositories.bzl%gleam_hex_repository rule. 
# DO NOT EDIT.
load("@gazelle//:def.bzl", "gazelle")
load("@rules_gleam//gleam:defs.bzl", "gleam_library")

package(
    default_visibility = ["//visibility:public"],
)

# To be referenced by @gleam_hex_repositories_config
filegroup(
    name = "srcs_for_dep_analysis",
    srcs = ["REPO.bazel", "gleam.toml"] + glob([
        "**/BUILD.bazel",
        "**/BUILD",
        "**/*.gleam",
        "**/*.hrl",
        "**/*.erl",
        "**/*.app"
    ], allow_empty = True, exclude = ["BUILD"]),
)

gazelle(
    name = "gazelle",
    gazelle = "@rules_gleam//gazelle",
)
""")
    ctx.extract("%s/contents.tar.gz" % TEMP_DIR, output = TEMP_DIR)
    if ctx.path("%s/src" % TEMP_DIR).exists:
        ctx.extract("%s/contents.tar.gz" % TEMP_DIR, output = ".", strip_prefix = "src")
    else: 
        ctx.extract("%s/contents.tar.gz" % TEMP_DIR, output = ".")
    copy(ctx, "%s/gleam.toml" % TEMP_DIR, "gleam.toml")
    ctx.delete(TEMP_DIR)

    _gazelle_label = Label("@rules_gleam_internal_tools//:bin/gazelle{}".format(executable_extension(ctx)))
    _gazelle = ctx.path(_gazelle_label)
    watch(ctx, _gazelle)

    cmd = [
        _gazelle,
        "-mode",
        "fix",
        "-gleam_external_repo",
        "-gleam_compiler_path",
        _gleam_compiler_path(ctx),
        "-repo_root",
        ctx.path(""),
    ]
    cmd.append(ctx.path(""))
    ctx.report_progress("Runnning Gazelle")

    result = env_execute(ctx, cmd)
    if result.return_code:
        fail("failed to generate BUILD files for %s: %s. err: %s" % (
            ctx.attr.module_name,
            result.stdout,
            result.stderr,
        ))

gleam_hex_repository = repository_rule(
    _gleam_hex_repository,
    doc = """
    Creates a repository with the Gleam hex repository.
    """,
    attrs = {
        "module_name": attr.string(doc = "The Hex package module name to download. This will be used as the root import path."),
        "checksum": attr.string(doc = "The checksum of the outerpackage we got from the manifest.toml file"),
        "version": attr.string(doc = "Semver version for the module"),
        "otp_app": attr.string(doc = "The otp_app from the module"),
        "deps": attr.label_list(doc = "The external deps that this module depends on.")
    },
)

def _gleam_hex_repositories_config_impl(ctx):
    REPOES = {}
    for index, repo_file in enumerate(ctx.attr.repoes):
        REPOES[repo_file] = """gleam_repository(
    name = "{MODULE_NAME}",
    module_name = "{MODULE_NAME}",
    repo_file = "{REPO_FILE}",
)""".format(
            MODULE_NAME = ctx.attr.modules[index],
            REPO_FILE = repo_file,
        )

    ctx.file("BUILD.bazel", """# This file is generated by the @rules_gleam//:gleam_hex/repositories.bzl%gleam_hex_repositories_config rule. 
# DO NOT EDIT.
load("@rules_gleam//gleam:defs.bzl", "gleam_repository")

package (
    default_visibility = ["//visibility:public"],
)

{REPOES}
""".format(
        REPOES = "\n\n".join(REPOES.values()),
    ))

    ctx.file("defs.bzl", """# This file is generated by the @rules_gleam//:gleam_hex/repositories.bzl%gleam_hex_repositories_config rule. 
# DO NOT EDIT.
DEPS = [
{REPOES}    
]""".format(REPOES = "\n".join(["   Label(\"%s\")," % repo_file for repo_file in ctx.attr.repoes])))

gleam_hex_repositories_config = repository_rule(
    _gleam_hex_repositories_config_impl,
    doc = "Create a centralized configuration for all hex repositories declared in the manifest.toml.",
    attrs = {
        "modules": attr.string_list(
            doc = "The list of repos module targets to extract the gleam modules from.",
        ),
        "repoes": attr.string_list(
            doc = "The repo to explore the import paths from. Must be a label pointing to the REPO file.",
        ),
    },
)

def _hex_tar_url(module, version):
    return "https://repo.hex.pm/tarballs/{module}-{version}.tar".format(
        module = module,
        version = version,
    )

# A macro (like a repository rule) to download hex repositories.
def gleam_hex_repositories(module_ctx, *, gleam_toml, _get_hex_repos = Label("@rules_gleam_internal_tools//:bin/get_hex_repos"), _module_prefix = "hex_"):
    """Creates repositories with the Gleam hex repository.

    Args:
        module_ctx (module_ctx): The module context.
        *: Additional arguments.
        gleam_toml (Label): The path to the gleam.toml file to be included.
        _get_hex_repos (Label): The path to the get_hex_repos script to translate the manifest.toml to json
          that bazel can consume.
        _module_prefix (str): The prefix to add to the module name to create the repository name.

    Returns:
        A list of module names.
    """
    repos = []
    if gleam_toml != None:
        file = module_ctx.path(gleam_toml).dirname.get_child("manifest.toml")
        if file.exists:
            get_hex_repos = module_ctx.path(_get_hex_repos)
            module_ctx.watch(file)
            module_ctx.watch(get_hex_repos)
            if not file.exists:
                fail("Could not find manifest.toml at the gleam.toml location %s" % gleam_toml.path)

            dependencies = module_ctx.execute([get_hex_repos, "--manifest", file])
            if dependencies.return_code:
                fail("failed to read manifest.toml file: %s" % dependencies.stderr)

            dep_json = json.decode(dependencies.stdout)
            repos = dep_json.get("repos", default = [])

    for repo in repos:
        gleam_hex_repository(
            name = _module_prefix + repo.get("module_name"),
            module_name = repo.get("module_name"),
            checksum = repo.get("checksum"),
            version = repo.get("version"),
            otp_app = repo.get("otp_app"),
            # deps = [Label("@%s%s//:REPO" % (_module_prefix, dep)) for dep in repo.get("deps")],
        )

    gleam_hex_repositories_config(
        name = "gleam_hex_repositories_config",
        modules = [_module_prefix + repo.get("module_name") for repo in repos],
        repoes = ["@" + _module_prefix + repo.get("module_name") + "//:srcs_for_dep_analysis" for repo in repos],
    )

    return [_module_prefix + repo.get("module_name") for repo in repos]

