"""Helper functions for Gleam JS rules."""

load("@bazel_skylib//lib:paths.bzl", "paths")
load("//gleam/js:provider.bzl", "GleamJsPackageInfo")

COMMON_ATTRS = {
    "data": attr.label_list(
        allow_files = True,
        doc = "Extra files to be added to the runfiles.",
    ),
    "strip_src_prefix": attr.string(
        doc = "The prefix to strip from the source file paths when compiling.",
        default = "",
    ),
}

GLEAM_ARTEFACTS_DIR = "_gleam_artefacts"

def get_gleam_compiler(ctx):
    toolchain = ctx.toolchains["//gleam_tools:toolchain_type"].gleamtools
    return toolchain.compiler

def get_js_prelude(ctx):
    toolchain = ctx.toolchains["//gleam_tools:toolchain_type"].gleamtools
    return toolchain.js_prelude

def declare_inputs(ctx, srcs):
    """Prepares and stages source files for the Gleam compiler.

    The resulting directory structure passed to the compiler will be:
        .
        ├── gleam.toml
        └── src/
            ├── some_source.gleam          (symlink)
            └── another_source.gleam       (symlink)

    Args:
        ctx: The Bazel rule context object.
        srcs (list): A list of source `File` objects to be prepared.

    Returns:
        A `struct` containing the prepared input files
    """
    toml_file = ctx.actions.declare_file("gleam.toml")
    ctx.actions.write(
        toml_file,
        """
name = "placeholder"
version = "0.0.0"
target = "javascript"
        """,
    )

    # Build inputs.
    sources = []
    for src in srcs:
        input_src = ctx.actions.declare_file(paths.join("src", strip_src_prefix(ctx, src.path)))
        ctx.actions.symlink(output = input_src, target_file = src)
        sources.append(input_src)

    sources.append(toml_file)
    return struct(
        toml_file = toml_file,
        sources = sources,
    )

def declare_runtime_mjs(ctx, output_mjs, deps):
    """Declares and assembles a depset of runtime JavaScript module files.

    This includes the Gleam JS prelude, the modules compiled by the current
    target, and the modules from transitive dependencies.

    Args:
        ctx: The Bazel rule context object.
        output_mjs (list): A list of `.mjs` `File` objects generated by the current target.
        deps (list): A list of dependency targets.

    Returns:
        A `depset` containing all required `.mjs` files for runtime.
    """
    direct_files = []
    transitive_files = []

    direct_files = direct_files + output_mjs
    for dep in deps:
        if GleamJsPackageInfo in dep:
            transitive_files.append(dep[GleamJsPackageInfo].js_module)
    return (depset(direct = direct_files, transitive = transitive_files), {"_main/gleam.mjs": get_js_prelude(ctx)})

def declare_outputs(ctx, srcs):
    """Calculates module names and declares compilation output files.

    For each source file provided, this function generates a corresponding
    module name by replacing path separators with '@'. It then declares
    the expected output files for compilation, including .mjs and .cache artifacts.

    Args:
        ctx: The Bazel rule context object, used for declaring files.
        srcs (list): A list of source `File` objects.
    Returns:
        A struct containing lists of the generated names and files.
    """
    js_files = []
    cache_files = []
    module_names = []

    for src in srcs:
        src_path = strip_src_prefix(ctx, src.path)
        module_name = paths.replace_extension(src_path, "").replace("/", "@")

        # Unlike, a erl build, output mjs isn't flatten to "@" path, but hierarchical folder.
        js_files.append(ctx.actions.declare_file(paths.basename(paths.replace_extension(src_path, "")) + ".mjs"))
        cache_files.append(ctx.actions.declare_file(module_name + ".cache"))
        cache_files.append(ctx.actions.declare_file(module_name + ".cache_meta"))
        cache_files.append(ctx.actions.declare_file(module_name + ".cache_inline"))
        module_names.append(module_name)

    all_files = js_files + cache_files
    all_files_include_binary = all_files

    return struct(
        js_files = js_files,
        cache_files = cache_files,
        module_names = module_names,
        all_files = all_files,
        all_files_include_binary = all_files_include_binary,
    )

def declare_libs(ctx, deps):
    """Stages dependency artifacts into a standard library directory.

    This function assembles a directory structure that can be passed to the
    compiler via a library flag (`--lib`). It populates the directory with the
    necessary compilation artifacts from transitive dependencies.

    The created directory structure looks like this:

        lib/javascript
        └── build_target_name
            ├── gleam.mjs # prelude.
            ├── *.mjs
            └── _gleam_artefacts
                 └── *.cache


    Args:
        ctx: The Bazel rule context object.
        deps (list): A list of targets providing `GleamJsPackageInfo`.

    Returns:
        tuple: A tuple containing:
            - depset: A depset of all files staged in the lib directory.
            - str: The path to the root of the created `lib` directory.
    """
    lib_inputs = []
    lib_path = paths.join("lib", "javascript")

    for dep in deps:
        if GleamJsPackageInfo in dep:
            target = dep[GleamJsPackageInfo]
            for file in target.js_module.to_list():
                link = ctx.actions.declare_file(paths.join(lib_path, target.target_name, paths.basename(file.path)))
                ctx.actions.symlink(
                    output = link,
                    target_file = file,
                )
                lib_inputs.append(link)

            for file in target.gleam_cache.to_list():
                link = ctx.actions.declare_file(paths.join(lib_path, target.target_name, GLEAM_ARTEFACTS_DIR, paths.basename(file.path)))
                ctx.actions.symlink(
                    output = link,
                    target_file = file,
                )
                lib_inputs.append(link)

    return (lib_inputs, lib_path if len(lib_inputs) > 0 else ".")

def strip_src_prefix(ctx, src):
    """
    Strip the prefix from the source path.

    Args:
        ctx (object): The Bazel context.
        src (str): The source path.

    Returns:
        str: The source path with the prefix stripped off.
    """

    if src.startswith(ctx.bin_dir.path):
        src = src.removeprefix(ctx.bin_dir.path + "/")
    prefix = ctx.attr.strip_src_prefix
    if not prefix.endswith("/"):
        prefix = prefix + "/"
    if prefix:
        return src.removeprefix(prefix)
    return src
