load("//gleam_tools:coded_versions.bzl", "ERL_VERSIONS", "VERSIONS")
load("//gleam_tools:platforms.bzl", "ERL_PLATFORMS", "PLATFORMS")

def _gleam_toolchain_repository_impl(repository_ctx):
    version = repository_ctx.attr.version
    platform = repository_ctx.attr.platform

    integrity = VERSIONS[version]["platforms"][platform]
    url_template = VERSIONS[version]["download_url_template"]
    url = url_template.format(
        version = version,
        platform = platform,
    )

    # This will extract a binary file at root.
    repository_ctx.download_and_extract(
        url = url,
        sha256 = integrity.replace("sha256:", ""),
        stripPrefix = "",
    )
    exe = "gleam"
    if repository_ctx.os.name.startswith("windows"):
        exe = "gleam.exe"

    js_prelude = repository_ctx.execute(["./%s" % exe, "export", "javascript-prelude"])
    if js_prelude.return_code:
        fail("failed to produce js prelude from gleam compiler: %s" % js_prelude.stderr)
    
    repository_ctx.file("gleam.mjs", js_prelude.stdout)

    build_content = """# Generated by repositories.bzl
load("@rules_gleam//gleam_tools:toolchain.bzl", "gleam_toolchain")

exports_files(["{EXE}"])

gleam_toolchain (
    name = "gleam_toolchain",
    compiler = ":{EXE}",
    js_prelude = ":gleam.mjs",
)
"""
    repository_ctx.file("BUILD.bazel", build_content.format(EXE = exe))

# Use this to enumerate associated targets
gleam_toolchain_repository = repository_rule(
    _gleam_toolchain_repository_impl,
    doc = "Generate a repository that contains tooling for a particular tool chain, platform",
    attrs = {
        "version": attr.string(mandatory = True, values = VERSIONS.keys()),
        "platform": attr.string(mandatory = True, values = PLATFORMS.keys()),
    },
)

def _toolchains_repositories_impl(repository_ctx):
    build_content = """# Generated by repositories.bzl
"""

    for [platform, meta] in PLATFORMS.items():
        build_content += """
toolchain(
    name = "{platform}_toolchain",
    exec_compatible_with = {compatible_with},
    toolchain = "@{prefix}{platform}//:gleam_toolchain",
    toolchain_type = "@rules_gleam//gleam_tools:toolchain_type",
)
""".format(
            platform = platform.replace("-", "_"),
            compatible_with = meta.compatible_with,
            prefix = repository_ctx.attr.toolchain_repo_prefix,
        )

    # Base BUILD file for this repository
    repository_ctx.file("BUILD", build_content)

toolchains_repositories = repository_rule(
    _toolchains_repositories_impl,
    doc = """Creates a repository with toolchain definitions for all known platforms
     which can be registered or selected.""",
    attrs = {
        "toolchain_repo_prefix": attr.string(doc = "The prefix to used for generating tool chain repos."),
    },
)

def _gleam_erlang_toolchain_repository_impl(repository_ctx):
    version = repository_ctx.attr.version
    platform = repository_ctx.attr.platform

    integrity = ERL_VERSIONS[version]["platforms"][platform]
    url_template = ERL_VERSIONS[version]["download_url_template"]
    url = url_template.format(
        version = version,
        platform = platform,
    )

    # This will extract a binary file at root.
    repository_ctx.download_and_extract(
        url = url,
        sha256 = integrity.replace("sha256:", ""),
        stripPrefix = "",
    )
    ext = ""
    if repository_ctx.os.name.startswith("windows"):
        ext = ".exe"

    build_content = """# Generated by repositories.bzl
load("@rules_gleam//gleam_tools:toolchain.bzl", "gleam_erlang_toolchain")

filegroup(
    name = "otp",
    srcs = glob(["usr/local/lib/erlang/**/*"]),
)

gleam_erlang_toolchain (
    name = "gleam_erlang_toolchain",
    escript = ":usr/local/lib/erlang/bin/escript{EXT}",
    erl = ":usr/local/lib/erlang/bin/erl{EXT}",
    erlc = ":usr/local/lib/erlang/bin/erlc{EXT}",
    otp = ":otp",
)
"""
    repository_ctx.file("BUILD.bazel", build_content.format(EXT = ext))

gleam_erlang_toolchain_repository = repository_rule(
    _gleam_erlang_toolchain_repository_impl,
    doc = "Generate a repository that contains tooling for a particular tool chain, platform",
    attrs = {
        "version": attr.string(mandatory = True, values = ERL_VERSIONS.keys()),
        "platform": attr.string(mandatory = True, values = ERL_PLATFORMS.keys()),
    },
)

def _gleam_erlang_toolchains_repositories_impl(repository_ctx):
    build_content = """# Generated by repositories.bzl
"""

    for [platform, meta] in ERL_PLATFORMS.items():
        build_content += """
toolchain(
    name = "{platform}_toolchain",
    exec_compatible_with = {compatible_with},
    toolchain = "@{prefix}{platform}//:gleam_erlang_toolchain",
    toolchain_type = "@rules_gleam//gleam_tools:erlang_toolchain_type",
)
""".format(
            platform = platform.replace("-", "_"),
            compatible_with = meta.compatible_with,
            prefix = repository_ctx.attr.toolchain_repo_prefix,
        )

    # Base BUILD file for this repository
    repository_ctx.file("BUILD", build_content)

gleam_erlang_toolchains_repositories = repository_rule(
    _gleam_erlang_toolchains_repositories_impl,
    doc = """Creates a repository with toolchain definitions for all known platforms
     which can be registered or selected.""",
    attrs = {
        "toolchain_repo_prefix": attr.string(doc = "The prefix to used for generating tool chain repos."),
    },
)

def register_toolchains(*, version = "v1.12.0", erl_version = "latest"):
    """Registers the gleam compiler toolchain.

    Args:
        version: the version of the compiler.
        erl_version: the version of the erlang compiler.

    Returns:
        A list of the names of the generated compiler repositories.
    """
    prefix = "gleam_compiler_"
    compiler_repos = []
    for platform in PLATFORMS.keys():
        gleam_toolchain_repository(
            # This name is referenced by toolchains_repositories, so careful.
            name = prefix + platform.replace("-", "_"),
            platform = platform,
            version = version,
        )
        compiler_repos.append(prefix + platform.replace("-", "_"))
    toolchains_repositories(
        name = "gleam_toolchains",
        toolchain_repo_prefix = prefix,
    )

    erl_prefix = "gleam_erlang_compiler_"
    for platform in ERL_PLATFORMS.keys():
        gleam_erlang_toolchain_repository(
            # This name is referenced by toolchains_repositories, so careful.
            name = erl_prefix + platform.replace("-", "_"),
            platform = platform,
            version = erl_version,
        )

    gleam_erlang_toolchains_repositories(
        name = "gleam_erlang_toolchains",
        toolchain_repo_prefix = erl_prefix,
    )
    return compiler_repos
