// A PEG grammar to parse only imports and main function if there is a main function.
{
package parser

import (
	"fmt"
	"strconv"
	"strings"
)

// -----------------------------------------------------------------------------
// ## Go Helper Code
// -----------------------------------------------------------------------------
func toSlice[T any](v any) []T {
	if v == nil { return nil }
	if s, ok := v.([]any); ok {
		res := make([]T, len(s))
		for i, item := range s { res[i] = item.(T) }
		return res
	}
	val, ok := v.(T)
	if !ok { panic(fmt.Sprintf("failed to convert to slice: unexpected type %T for target type %T", v, *new(T))) }
	return []T{val}
}

// Helper functions for parsing literals
func parseInteger(text []byte) (int64, error) {
	s := strings.ReplaceAll(string(text), "_", "")
	if len(s) > 2 {
		switch s[0:2] {
		case "0x", "0X": return strconv.ParseInt(s[2:], 16, 64)
		case "0o", "0O": return strconv.ParseInt(s[2:], 8, 64)
		case "0b", "0B": return strconv.ParseInt(s[2:], 2, 64)
		}
	}
	return strconv.ParseInt(s, 10, 64)
}

func parseFloat(text []byte) (float64, error) {
	s := strings.ReplaceAll(string(text), "_", "")
	return strconv.ParseFloat(s, 64)
}

func unquoteString(text []byte) (string, error) { return strconv.Unquote(string(text)) }


// -----------------------------------------------------------------------------
// ## AST Node Definitions
// -----------------------------------------------------------------------------

type Node interface{}
type Statement interface{ Node }
type Expression interface{ Node }
type Type interface{ Node }
type Pattern interface{ Node }

type SourceFile struct { Statements []Node }
type Identifier struct { Name string }
type Discard struct { Name string }
type Parameter struct { Label, Name string; Type Type }
type Function struct {
    Public bool
    Name string
    Parameters []Parameter
    ReturnType Type
    ExternalAttributes []ExternalAttribute
}
type TargetAttribute struct {
    TargetLang string
}
type Import struct {
	Module      string
	Unqualified []UnqualifiedImport
	Alias       string
    Target *TargetAttribute
}
type ExternalAttribute struct {
    TargetLang string
    Module string
    Function string
}

// Represents a single item in an unqualified import list, e.g., `MyType` in `import gleam.{MyType}`.
type UnqualifiedImport struct {
	Name   string
	Alias  string
	IsType bool // Differentiates `type MyType` from `MyFunction`
}

}

// -----------------------------------------------------------------------------
// ## Grammar Entrypoint
// -----------------------------------------------------------------------------

SourceFile <- _ first:(Import / IgnoredType / Function / IgnoredContent)? rest:(_ (Import / IgnoredType / Function / IgnoredContent))* _ EOF {
    validStatements := []Node{}
    if first != nil {
		validStatements = append(validStatements, first)
	}
    if rest != nil {
        for _, s := range rest.([]any) {
            if s != nil {
				if val, ok := s.([]any); ok && val[1] != nil {
                	validStatements = append(validStatements, val[1].(Node))
				}
            }
        }
    }
    return SourceFile{Statements: validStatements}, nil
}

Function <- targetAttrs1:(TargetAttribute)* exattrs:(ExternalAttribute)* targetAttrs2:(TargetAttribute)* pub:("pub" __)? "fn" __ name:Name _ params:FunctionParameters returnGroup:(_ "->" _ Type)? _ body:IgnoredBlock? {
    f := Function{Name: name.(string)}
    if pub != nil { f.Public = true }
    if params != nil { f.Parameters = params.([]Parameter) }
    if returnGroup != nil { f.ReturnType = returnGroup.([]any)[3].(Type) }
    if exattrs != nil {
        f.ExternalAttributes = toSlice[ExternalAttribute](exattrs)
    }
    return f, nil
}

// ExternalAttribute parses a single @external(...) line and its arguments.
ExternalAttribute <- "@" _ "external" _ "(" _ args:ExternalArgs _ ")" _ {
	return args, nil
}

// ExternalArgs parses the three required arguments for the attribute.
ExternalArgs <- target:("erlang" / "javascript") _ "," _ module:StringArg _ "," _ function:StringArg {
	return ExternalAttribute{
		TargetLang:   string(target.([]uint8)),
		Module:   strings.Trim(module.(string), "\""),
		Function: strings.Trim(function.(string), "\""),
	}, nil
}

StringArg <- "\"" [^"]* "\"" { return string(c.text), nil }

FunctionParameters <- "(" _ first:FunctionParameter? rest:(_ "," _ FunctionParameter)* _ ","? _ ")" {
    if first == nil {
        return []Parameter{}, nil
    }
    // Start the list with the first item. The type assertion is safe here.
    params := []Parameter{first.(Parameter)}

    // If there are more items, loop through them.
    if rest != nil {
        for _, paramPhrase := range toSlice[[]any](rest) {
            params = append(params, paramPhrase[3].(Parameter))
        }
    }
    return params, nil
}

LambdaFunction <- "fn" _ "(" _ first:LambdaFunctionParameter? rest:(_ "," _ LambdaFunctionParameter)*  _ ","? _ ")" returnGroup:(_ "->" _ LambdaFunctionParameter)? {
    return nil, nil
}
LambdaFunctionParameter <- t:(LambdaFunction / Type / TupleType) { return t, nil }

FunctionParameter <- p:(LabeledNameParam / NameParam / DiscardParam) typ:TypeAnnotation? {
	param, ok := p.(Parameter)
    if !ok {
        return nil, nil
    }
	if typ != nil { param.Type = typ.(Type) }
	return param, nil
}
TypeAnnotation <- ":" _ t:(TypeAnnotationContent) { return t, nil }
TypeAnnotationContent <- t:(LambdaFunction / TupleType / Type) { return t, nil}
TupleType <- "#(" _ first:(TypeAnnotationContent) rest:(_ "," _ TypeAnnotationContent _)* _ ")" { return nil, nil }
Type <- mod:(Name ".")? name:(Name / UpName) (_ gp:GenericParams)? {
    return name.(string), nil
}
IgnoredType <- pub:("pub" __)? opaque:("opaque" __)? "type" __ (Type) (_ IgnoredBlock)? {
    return nil, nil
}
GenericParams <- "(" _ first:(TypeAnnotationContent) rest:(_ "," _ TypeAnnotationContent)* _ ","? ")" { return nil, nil }
GenericParam <- mod:(Name ".")? param:(Name / UpName) (_ GenericParams _)? { return nil, nil }
LabeledNameParam <- label:Label _ name:Identifier {
	return Parameter{Label: label.(string), Name: name.(Identifier).Name}, nil
}
NameParam <- name:Identifier { return Parameter{Name: name.(Identifier).Name}, nil }
DiscardParam <- name:Discard { return Parameter{Name: name.(string)}, nil }
Identifier <- Name { return Identifier{Name: string(c.text)}, nil }
Discard <- DiscardName { return Discard{Name: string(c.text)}, nil }
Label <- Name { return string(c.text), nil }

IgnoredContent <- expr:(!(
    TargetAttribute _ "fn" _ /
    TargetAttribute _ "import" /
    TargetAttribute _ "pub" _ "fn" _ /
    "import" _ /
    ExternalAttribute _ /
    # To distinguish from anonymous function
    "fn" _ Name /
    "pub" _ "fn" _ /
    "type" _ /
    "pub" _ "type" _ /
    "pub" _ "opaque" _ "type" _ /
    "//" _
) .)+ {
    return nil, nil
}
IgnoredBlock <- "{" expr:(IgnoredBlock / !"}" .)* "}" {
    return nil, nil
}

// -----------------------------------------------------------------------------
// ## Whitespace & Comments
// -----------------------------------------------------------------------------

_ "whitespace" <- (Whitespace / Comment)*
__ "whitespace" <- (Whitespace / Comment)+
Whitespace <- [ \t\r\n]
Comment <- "//" (!'\n' .)* { return nil, nil }

// -----------------------------------------------------------------------------
// ## Module-level & Top-level Statements
// -----------------------------------------------------------------------------

TargetAttribute <- "@" _ "target" _ "(" _ args:TargetArgs _ ")" _ {
	return args, nil
}

TargetArgs <- target:("erlang" / "javascript") {
	return &TargetAttribute{
		TargetLang:   string(target.([]uint8)),
	}, nil
}

Import <- targetAttribute:TargetAttribute? _ "import" __ mod:Module unqual:(_ "." _ UnqualifiedImports)? alias:(_ "as" __ Identifier)? {
    imp := Import{Module: mod.(string)}
    if alias != nil {
        imp.Alias = alias.([]any)[3].(Identifier).Name
    }
    if unqual != nil {
        imp.Unqualified = unqual.([]any)[3].([]UnqualifiedImport)
    }
    if target, ok := targetAttribute.(*TargetAttribute); ok {
        imp.Target = target
    }
    return imp, nil
}

Module <- Name (_ "/" _ Name)* {
    return string(c.text), nil
}

// This rule now just handles the curly braces and calls the list-builder.
UnqualifiedImports <- "{" _ items:UnqualifiedImportList? _ "}" {
    if items == nil {
        return []UnqualifiedImport{}, nil
    }
    return items, nil
}

// This new rule is dedicated to building the list of imports correctly.
UnqualifiedImportList <- first:UnqualifiedImport rest:(_ "," _ UnqualifiedImport)* _ ","? {
    // Start the list with the first item. The type assertion is safe here.
    imports := []UnqualifiedImport{first.(UnqualifiedImport)}

    // If there are more items, loop through them.
    if rest != nil {
        for _, pair := range toSlice[[]any](rest) {
            // Extract the UnqualifiedImport, which is the 4th element.
            imports = append(imports, pair[3].(UnqualifiedImport))
        }
    }
    return imports, nil
}

UnqualifiedImport <- itemType:("type" __)? name:(UpName / Name) alias:(_ "as" __ (UpName / Name))? {
    imp := UnqualifiedImport{Name: name.(string)}
    if itemType != nil {
        imp.IsType = true
    }
	if alias != nil {
		imp.Alias = alias.([]any)[3].(string)
	}
    return imp, nil
}

// -----------------------------------------------------------------------------
// ## Expressions
// -----------------------------------------------------------------------------


Name        <- !KEYWORD [a-z_] [a-z0-9_]* { return string(c.text), nil }
UpName      <- [A-Z] [a-zA-Z0-9]* { return string(c.text), nil }
DiscardName <- "_" [a-z0-9_]*

KEYWORD <- ("as" / "case" / "const" / "if" / "import" / "let" / "pub" / "type" / "use") !([a-zA-Z0-9_])
EOF     <- !.